# 仰晨毛猪系爱鹤咪斑鸠
# 时间：2022/7/11 00:45:08

"""字符串是一个不可变的字符序列

什么叫字符串驻留机制呢?
·仅保存一份相同且不可变字符串的方法，不同的值被存放在字符串的驻留池中,
 Python的驻留机制对相同的字符串只保留一份拷贝，
后续创建相同字符串时，不会开辟新空间，而是把该字符串的地址赋给新创建的变量
"""
树子 = 666
素质 = 666
print(id(树子))  # 2245776459696
print(id(素质))  # 2245776459696

荔枝 = "你干嘛"
励志 = '你干嘛'
理智 = """你干嘛"""
print(id(荔枝))  # 2245771179952
print(id(励志))  # 2245771179952
print(id(理智))  # 2245771179952

"""
·驻留机制的几种情况(交互模式)
·字符串的长度为0或1时
·符合标识符的字符串
·字符串只在编译时进行驻留，而非运行时[-5,256]之间的整数数字

.sys中的intern方法强制2个字符串指向同一个对象.PyCharm对字符串进行了优化处理
"""

a = -6
b = -6
print(a is b)  # PyCharm对字符串进行了优化处理，这里是true，在python中是false

c = "ikun@"
d = "ikun@"
print(c is d)  # ·python符合标识符的字符串才行（@不是标识符），PyCharm对字符串进行了优化处理，这里是true，在python中是false

"""字符串驻留机制的优缺点
·当需要值相同的字符串时，可以直接从字符串池里拿来使用，避免频繁的创建和销毁，提升效率和节约内存，因此拼接字符串和修改字符串是会比较影响性能的。
·
·在需要讲行字符串拼接时建议使用str类型的join方法，而非+ ,因为join()方法是先计算出所有字符中的长度，然后再拷贝，只new一次对象，效率要比"+"效率高
"""

# ----------------------------------查找-------------------------------------------------#

"""方法名称             作用
index()      查找子串substr第一次出现的位置,如果查找的子串不存在时，则抛出ValueError
rindex()     查找子串substr最后一次出现的位置，如果查找的子串不存在时，则抛出ValueError
find()      查找子串substr第一次出现的位置,如果查找的子串不存在时，则返回-1
rfind()     查找子串substr最后一次出现的位置,如果查找的子串不存在时，则返回-1
"""

字符串v = "hello，苏珊，low"

print(字符串v.find('lo'))  # 3
print(字符串v.index('lo'))  # 3
print(字符串v.rfind('lo'))  # 9
print(字符串v.rindex('lo'))  # 9

print(字符串v.find("鸡太美"))  # -1
# print(字符串v.index('鸡太美')) # 报错 ValueError: substring not found


# --------------------------------转换-----------------------------------------------------#
""" 方法名称       作用
upper()         把字符串中所有字符都转成大写字母
lower()         把字符串中所有字符都转成小写字母
swapcase()      把字符串中所有大写字母转成小写字母，把所有小写字母都转成大写字母
capitalize()    把第一个字符转换为大写，把其余字符转换为小写
title()         把每个单词的第一个字符转换为大写，把每个单词的剩余字符转换为小写
"""

字符串x = 'ikun,is KING,虾头'

a = 字符串x.upper()  # 字符串对象发生变化会产生新的字符串对象（开辟新的内存空间）
print(字符串x, id(字符串x), '\n', a, id(a))  # ikun,is KING,虾头 1824396437184   IKUN,IS KING,虾头 1824396437744

字符串a = 'abcd'

b = 字符串a.lower()  # 就算内容没变也会产生一个新的字符串变量
print(字符串a, id(字符串a))  # abcd 1745934968432
print(b, id(b))  # abcd 1745934969008

字符串c = 'ikun,is KING,你记着'

print(字符串c.capitalize())  # 把第一个字符转换为大写，把其余字符转换为小写                  Ikun,is king,你记着

print(字符串c.swapcase())  # 大小写互换                                             IKUN,IS king,你记着

print(字符串c.title())  # 每个单词的第一个字符转换为大写，把每个单词的剩余字符转换为小写   Ikun,Is King,你记着

# --------------------------------对齐-----------------------------------------------------#

"""
.center()        居中对齐，第1个参数指定宽度，第2个参数指定填充符,第2个参数是可选的，默认是空格,如果设置宽度小于实际宽度则则返回原字符串

.ljust()         左对齐，第1个参数指定宽度，第2个参数指定填充符,第2个参数是可选的，默认是空格如果设置宽度小于实际宽度则则返回原字符串

.rjust()         右对齐,第1个参数指定宽度，第2个参数指定填充符,第2个参数是可选的，默认是空格如果设置宽度小于实际宽度则则返回原字符串

.zfil1()         右对齐，左边用0填充,该方法只接收一个参数，用于指定字符串的宽度，如果指定的宽度小于等于字符串的长度，返回字符串本身
"""

sss = "有个苏珊阿姨在楼下买油饼。"

print(sss.center(20, '*'))  # ***有个苏珊阿姨在楼下买油饼。****
print(sss.center(20))  # 有个苏珊阿姨在楼下买油饼。
print(sss.center(2))  # 有个苏珊阿姨在楼下买油饼。

print(sss.ljust(20, '*'))  # 有个苏珊阿姨在楼下买油饼。*******
print(sss.ljust(20))  # 有个苏珊阿姨在楼下买油饼。

print(sss.rjust(20, '*'))  # *******有个苏珊阿姨在楼下买油饼。
print(sss.rjust(20))  # 有个苏珊阿姨在楼下买油饼。
print(sss.rjust(1))  # 有个苏珊阿姨在楼下买油饼。

print(sss.zfill(20))  # 0000000有个苏珊阿姨在楼下买油饼。
print(sss.zfill(3))  # 有个苏珊阿姨在楼下买油饼。

print('+--51050'.zfill(10))  # +00--51050
print('-556'.zfill(10))  # -000000556
print('+556'.zfill(10))  # +000000556
print('=556'.zfill(10))  # 000000=556

# --------------------------------分割-----------------------------------------------------


"""
            从字符串的左边开始劈分，默认的劈分字符是空格字符串,返回的值都是一个列表
.split()     以通过参数sep指定劈分字符串是的劈分符
            通过参数maxsplit指定劈分字符串时的最大劈分次数，在经过最大次劈分之后，剩余的子串会单独做为一部分

            从字符串的右边开始劈分，默认的劈分字符是空格字符串,返回的值都是一个列表
.rsplit()    以通过参数sep指定劈分字符串是的劈分符
            通过参数maxsplit指定劈分字符串时的最大劈分次数，在经过最大次劈分之后，剩余的子串会单独做为一部分
"""

ss = "蔡徐村 苏珊阿姨 在 树枝上 卖荔枝"
s = ss.split()  # 默认空格用分割
print(s)  # ['蔡徐村', '苏珊阿姨', '在', '树枝上', '卖荔枝']

s1 = "蔡徐村@苏珊阿姨@在@树枝上@卖荔枝"

print(s1.split())  # ['蔡徐村@苏珊阿姨@在@树枝上@卖荔枝']
print(s1.split(sep='@'))  # ['蔡徐村', '苏珊阿姨', '在', '树枝上', '卖荔枝']
print(s1.split(sep='@', maxsplit=2))  # ['蔡徐村', '苏珊阿姨', '在@树枝上@卖荔枝']

print(s1.rsplit())  # ['蔡徐村@苏珊阿姨@在@树枝上@卖荔枝']
print(s1.rsplit(sep='@'))  # ['蔡徐村', '苏珊阿姨', '在', '树枝上', '卖荔枝']
print(s1.rsplit(sep='@', maxsplit=1))  # ['蔡徐村@苏珊阿姨@在@树枝上', '卖荔枝']

"""
isidentifier()      判断指定的字符串是不是合法的标识符
isspace()           判断指定的字符串是否全部由空白字符组成(回车、换行，水平制表符)
isalpha()           判断指定的字符串是否全部由字母组成
isdecimal()         判断指定字符串是否全部由十进制的数字组成
isnumeric()         判断指定的字符串是否全部由数字组成
isalnum()           判断指定字符串是否全部由字母和数字组成
"""

# 判断指定的字符串是不是合法的标识符.isidentifier()
x = 'l556@'
print(x.isidentifier())  # False
print('l556'.isidentifier())  # True
print('牛马'.isidentifier())  # True
print('牛马。'.isidentifier())  # False
print('牛马_1'.isidentifier())  # True

# 判断指定的字符串是否全部由空白字符组成(回车、换行，水平制表符).isspace()
print('\n\t'.isspace())  # True
print(' '.isspace())  # True
print(''.isspace())  # False(啥都没有是false

# 判断指定的字符串是否全部由字母组成.isalpha() 。中文算字母组成
print('及时行乐'.isalpha())  # True
print('ikunkk'.isalpha())  # True
print('仰晨2022'.isalpha())  # False
print('timi@。，'.isalpha())  # False

# 判断指定字符串是否全部由十进制的数字组成.isdecimal()
print('123'.isdecimal())  # True
print('12.3'.isdecimal())  # False
print('四'.isdecimal())  # False
print('Ⅳ'.isdecimal())  # False

# 判断指定的字符串是否全部由数字组成.isnumeric()
print('12.3'.isnumeric())  # False
print('123四'.isnumeric())  # True
print('Ⅳ'.isnumeric())  # True
print('ⅻ⁸⅘'.isnumeric())  # True
print('abc123'.isnumeric())  # False
print('壹零0'.isnumeric())  # True

# 判断指定字符串是否全部由字母和数字组成
print('iskun'.isalnum())  # True
print('is困'.isalnum())  # True
print('123kun'.isalnum())  # True
print('ⅻ⁸⅘12a啊'.isalnum())  # True
print('kun？'.isalnum())  # False
print('is kun'.isalnum())  # False

# --------------------------------替换-----------------------------------------------------
"""
字符串替换      replace()
第1个参数指定被替换的子串，第2个参数指定替换子串的字符串,该方法返回替换后得到的字符串，替换前的字符串不发生变化,调用该方法时可以通过第3个参数指定最大替换次数

字符串的合并     join()    将列表或元组中的字符串合并成一个字符串
"""

# 字符串替换.replace(*,*,*)
ssss = '你好，牛马、大牛马、超级牛马'
print(ssss.replace('牛马', '仰晨'))  # 你好，仰晨、大仰晨、超级仰晨
print(ssss.replace('牛马', '仰晨', 2))  # 你好，仰晨、大仰晨、超级牛马

# 字符串的合并('合并符'.join(要合并的东东))
列表bb = ['这里', '是', '为我', '所统帅的', '战场']
print(''.join(列表bb))  # 这里是为我所统帅的战场
print('~'.join(列表bb))  # 这里~是~为我~所统帅的~战场

元组bb = ('这里', '是', '让我', '忘却野心的', '战场')
print(''.join(元组bb))  # 这里是让我忘却野心的战场
print('~'.join(元组bb))  # 这里~是~让我~忘却野心的~战场

print('%'.join('字符串也是可以的哦'))  # 字%符%串%也%是%可%以%的%哦

# --------------------比较操作----------------------------------------------------------------------
"""
==比较的是value的值
is比较的是ID的值
"""
'''
·字符串的比较操作
·运算符:>,>=,<,<=,==,!=
·   比较规则:首先比较两个字符串中的第一个字符，如果相等则继续比较下一个字符，依次比较下去，
    直到两个字符串中的字符不相等时，其比较结果就是两个字符串的比较结果，两个字符串中的所有后续字符将不再被比较
    
·   比较原理:两上字符进行比较时，比较的是其ordinal value(原始值);调用内置函数ord可以得到指定字符的ordinal value。
    与内置函数ord对应的是内置函数chr,调用内置函数chr时指定ordinal value可以得到其对应的字符
'''
print(ord('树'))  # 26641
print(ord('荔'))  # 33620

print('树枝' > '荔枝')  # False
print('abc' > 'dd')  # False
print('dbc' > 'dd')  # False
print('ebc' > 'dd')  # True

# 结束牛马时间：2022.7.18 03：46
